"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceBackgroundAndRelight = exports.removeBackground = exports.searchAndReplace = exports.outpaint = exports.inpaint = exports.erase = void 0;
const axios_1 = __importDefault(require("axios"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const form_data_1 = __importDefault(require("form-data"));
const util_1 = require("../../util");
const error_1 = require("../../error");
const Util = __importStar(require("../../util"));
const RESOURCE = 'stable-image/edit';
var Endpoint;
(function (Endpoint) {
    Endpoint["ERASE"] = "erase";
    Endpoint["INPAINT"] = "inpaint";
    Endpoint["OUTPAINT"] = "outpaint";
    Endpoint["SEARCH_AND_REPLACE"] = "search-and-replace";
    Endpoint["REMOVE_BACKGROUND"] = "remove-background";
})(Endpoint || (Endpoint = {}));
/**
 * Stability AI Stable Image Erase (v2beta)
 *
 * @param image - Local filepath or public URL of the image to perform erase on
 * @param options - Erase Options
 */
async function erase(...args) {
    const [image, options] = args;
    const imagePath = new Util.ImagePath(image);
    const maskPath = (options === null || options === void 0 ? void 0 : options.mask) ? new Util.ImagePath(options.mask) : undefined;
    const formData = {
        image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
    };
    if (maskPath)
        formData.mask = fs_extra_1.default.createReadStream(await maskPath.filepath());
    if (options === null || options === void 0 ? void 0 : options.seed)
        formData.seed = options.seed;
    if (options === null || options === void 0 ? void 0 : options.outputFormat)
        formData.output_format = options.outputFormat;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_BETA, RESOURCE, Endpoint.ERASE), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    imagePath.cleanup();
    maskPath === null || maskPath === void 0 ? void 0 : maskPath.cleanup();
    if (response.status === 200) {
        return Util.processContentResponse(response.data, (options === null || options === void 0 ? void 0 : options.outputFormat) || Util.DEFAULT_OUTPUT_FORMAT, 'v2beta_stable_image_edit_erase');
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run stable image erase', response.data);
}
exports.erase = erase;
/**
 * Stability AI Stable Image Inpaint (v2beta)
 *
 * @param image - Local filepath or public URL of the image to inpaint
 * @param prompt - Prompt to use for inpainting
 * @param options - Inpaint Options
 */
async function inpaint(...args) {
    const [image, prompt, options] = args;
    const imagePath = new Util.ImagePath(image);
    const maskPath = (options === null || options === void 0 ? void 0 : options.mask) ? new Util.ImagePath(options.mask) : undefined;
    const formData = {
        image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
        prompt,
    };
    if (maskPath)
        formData.mask = fs_extra_1.default.createReadStream(await maskPath.filepath());
    if (options === null || options === void 0 ? void 0 : options.negativePrompt)
        formData.negative_prompt = options.negativePrompt;
    if (options === null || options === void 0 ? void 0 : options.seed)
        formData.seed = options.seed;
    if (options === null || options === void 0 ? void 0 : options.outputFormat)
        formData.output_format = options.outputFormat;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_BETA, RESOURCE, Endpoint.INPAINT), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    imagePath.cleanup();
    maskPath === null || maskPath === void 0 ? void 0 : maskPath.cleanup();
    if (response.status === 200) {
        return Util.processContentResponse(response.data, (options === null || options === void 0 ? void 0 : options.outputFormat) || Util.DEFAULT_OUTPUT_FORMAT, 'v2beta_stable_image_edit_inpaint');
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run stable image inpaint', response.data);
}
exports.inpaint = inpaint;
/**
 * Stability AI Stable Image Outpaint (v2beta)
 *
 * @param image - Local filepath or public URL of the image to outpaint
 * @param prompt - Prompt to use for outpainting
 * @param options - Outpaint Options
 */
async function outpaint(...args) {
    const [image, options] = args;
    const imagePath = new Util.ImagePath(image);
    const formData = {
        image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
    };
    if (options === null || options === void 0 ? void 0 : options.left)
        formData.left = options.left;
    if (options === null || options === void 0 ? void 0 : options.right)
        formData.right = options.right;
    if (options === null || options === void 0 ? void 0 : options.up)
        formData.up = options.up;
    if (options === null || options === void 0 ? void 0 : options.down)
        formData.down = options.down;
    if (options === null || options === void 0 ? void 0 : options.prompt)
        formData.prompt = options.prompt;
    if (options === null || options === void 0 ? void 0 : options.seed)
        formData.seed = options.seed;
    if (options === null || options === void 0 ? void 0 : options.outputFormat)
        formData.output_format = options.outputFormat;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_BETA, RESOURCE, Endpoint.OUTPAINT), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    imagePath.cleanup();
    if (response.status === 200) {
        return Util.processContentResponse(response.data, (options === null || options === void 0 ? void 0 : options.outputFormat) || Util.DEFAULT_OUTPUT_FORMAT, 'v2beta_stable_image_edit_outpaint');
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run stable image outpaint', response.data);
}
exports.outpaint = outpaint;
/**
 * Stability AI Stable Image Search and Replace (v2beta)
 *
 * @param image - Local filepath or public URL of the image to search and replace
 * @param prompt - Prompt to use for search and replace
 * @param searchPrompt - Prompt to search for
 * @param options - Search and Replace Options
 */
async function searchAndReplace(...args) {
    const [image, prompt, searchPrompt, options] = args;
    const imagePath = new Util.ImagePath(image);
    const formData = {
        image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
        prompt,
        search_prompt: searchPrompt,
    };
    if (options === null || options === void 0 ? void 0 : options.negativePrompt)
        formData.negative_prompt = options.negativePrompt;
    if (options === null || options === void 0 ? void 0 : options.seed)
        formData.seed = options.seed;
    if (options === null || options === void 0 ? void 0 : options.outputFormat)
        formData.output_format = options.outputFormat;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_BETA, RESOURCE, Endpoint.SEARCH_AND_REPLACE), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    imagePath.cleanup();
    if (response.status === 200) {
        return Util.processContentResponse(response.data, (options === null || options === void 0 ? void 0 : options.outputFormat) || Util.DEFAULT_OUTPUT_FORMAT, 'v2beta_stable_image_edit_search_and_replace');
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run stable image search and replace', response.data);
}
exports.searchAndReplace = searchAndReplace;
/**
 * Stability AI Stable Image Remove Background (v2beta)
 *
 * @param image - Local filepath or public URL of the image to remove the background from
 * @param options - Remove Background Options
 */
async function removeBackground(...args) {
    const [image, options] = args;
    const imagePath = new Util.ImagePath(image);
    const formData = {
        image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
    };
    if (options === null || options === void 0 ? void 0 : options.outputFormat)
        formData.output_format = options.outputFormat;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_BETA, RESOURCE, Endpoint.REMOVE_BACKGROUND), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    imagePath.cleanup();
    if (response.status === 200) {
        return Util.processContentResponse(response.data, (options === null || options === void 0 ? void 0 : options.outputFormat) || Util.DEFAULT_OUTPUT_FORMAT, 'v2beta_stable_image_edit_remove_background');
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run stable image remove background', response.data);
}
exports.removeBackground = removeBackground;
/**
 * Stability AI Stable Image Replace Background and Relight (v2beta)
 *
 * @param image - Local filepath or public URL of the image containing the subject
 * @param options - Replace Background and Relight Options
 */
async function replaceBackgroundAndRelight(...args) {
    const [image, options] = args;
    const imagePath = new Util.ImagePath(image);
    const backgroundRefPath = (options === null || options === void 0 ? void 0 : options.backgroundReference)
        ? new Util.ImagePath(options.backgroundReference)
        : undefined;
    const lightRefPath = (options === null || options === void 0 ? void 0 : options.lightReference)
        ? new Util.ImagePath(options.lightReference)
        : undefined;
    const formData = {
        subject_image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
    };
    // Required: either background_reference or background_prompt
    if (backgroundRefPath) {
        formData.background_reference = fs_extra_1.default.createReadStream(await backgroundRefPath.filepath());
    }
    if (options === null || options === void 0 ? void 0 : options.backgroundPrompt) {
        formData.background_prompt = options.backgroundPrompt;
    }
    // Optional parameters
    if (options === null || options === void 0 ? void 0 : options.foregroundPrompt)
        formData.foreground_prompt = options.foregroundPrompt;
    if (options === null || options === void 0 ? void 0 : options.negativePrompt)
        formData.negative_prompt = options.negativePrompt;
    if (options === null || options === void 0 ? void 0 : options.preserveOriginalSubject)
        formData.preserve_original_subject = options.preserveOriginalSubject;
    if (options === null || options === void 0 ? void 0 : options.originalBackgroundDepth)
        formData.original_background_depth = options.originalBackgroundDepth;
    if (options === null || options === void 0 ? void 0 : options.keepOriginalBackground)
        formData.keep_original_background = options.keepOriginalBackground;
    if (options === null || options === void 0 ? void 0 : options.lightSourceDirection)
        formData.light_source_direction = options.lightSourceDirection;
    if (lightRefPath) {
        formData.light_reference = fs_extra_1.default.createReadStream(await lightRefPath.filepath());
    }
    if (options === null || options === void 0 ? void 0 : options.lightSourceStrength)
        formData.light_source_strength = options.lightSourceStrength;
    if (options === null || options === void 0 ? void 0 : options.seed)
        formData.seed = options.seed;
    if (options === null || options === void 0 ? void 0 : options.outputFormat)
        formData.output_format = options.outputFormat;
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V2_BETA, RESOURCE, 'replace-background-and-relight'), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    // Cleanup temporary files
    imagePath.cleanup();
    backgroundRefPath === null || backgroundRefPath === void 0 ? void 0 : backgroundRefPath.cleanup();
    lightRefPath === null || lightRefPath === void 0 ? void 0 : lightRefPath.cleanup();
    if (response.status === 200 && typeof response.data.id === 'string') {
        return { id: response.data.id };
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run stable image replace background and relight', response.data);
}
exports.replaceBackgroundAndRelight = replaceBackgroundAndRelight;
//# sourceMappingURL=edit.js.map