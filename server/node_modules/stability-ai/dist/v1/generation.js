"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imageToImageMasking = exports.imageToImage = exports.textToImage = void 0;
const axios_1 = __importDefault(require("axios"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const form_data_1 = __importDefault(require("form-data"));
const util_1 = require("../util");
const error_1 = require("../error");
const Util = __importStar(require("../util"));
const RESOURCE = 'generation';
var Endpoint;
(function (Endpoint) {
    Endpoint["TEXT_TO_IMAGE"] = "text-to-image";
    Endpoint["IMAGE_TO_IMAGE"] = "image-to-image";
    Endpoint["IMAGE_TO_IMAGE_UPSCALE"] = "image-to-image/upscale";
    Endpoint["IMAGE_TO_IMAGE_MASKING"] = "image-to-image/masking";
})(Endpoint || (Endpoint = {}));
async function processArtifacts(artifacts) {
    const results = [];
    for (const artifact of artifacts) {
        const contentResponse = await Util.processContentResponse(artifact, 'png', 'v1_generation_text_to_image');
        results.push(contentResponse);
    }
    return results;
}
/**
 * Stability AI Text To Image (v1)
 *
 * @param text_prompts - Text prompts to use for generating the image
 * @param options - Additional options for the generation
 */
async function textToImage(...args) {
    const [engineId, textPrompts, options] = args;
    const body = {
        text_prompts: textPrompts,
        ...(options || {}),
    };
    const response = await axios_1.default.post(Util.makeUrl(util_1.APIVersion.V1, RESOURCE, engineId + '/' + Endpoint.TEXT_TO_IMAGE), body, {
        headers: {
            ...this.orgAuthHeaders,
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        validateStatus: undefined,
    });
    if (response.status === 200 && Array.isArray(response.data.artifacts)) {
        return processArtifacts(response.data.artifacts);
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run text to image', response.data);
}
exports.textToImage = textToImage;
/**
 * Stability AI Image To Image (v1)
 *
 */
async function imageToImage(...args) {
    const [engineId, textPrompts, initImage, options] = args;
    const imagePath = new Util.ImagePath(initImage);
    const formData = {
        init_image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
        text_prompts: textPrompts,
        ...(options || {}),
    };
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V1, RESOURCE, engineId + '/' + Endpoint.IMAGE_TO_IMAGE), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    imagePath.cleanup();
    if (response.status === 200 && Array.isArray(response.data.artifacts)) {
        return processArtifacts(response.data.artifacts);
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run image to image', response.data);
}
exports.imageToImage = imageToImage;
/**
 * Stability AI Image To Image Upscale (v1)
 *
 */
async function imageToImageMasking(...args) {
    const [engineId, textPrompts, initImage, options] = args;
    const imagePath = new Util.ImagePath(initImage);
    let maskPath = undefined;
    let otherOptions;
    if ('mask_image' in options) {
        maskPath = new Util.ImagePath(options.mask_image);
        const { ...other } = options;
        otherOptions = other;
    }
    else {
        const { ...other } = options;
        otherOptions = other;
    }
    const formData = {
        init_image: fs_extra_1.default.createReadStream(await imagePath.filepath()),
        text_prompts: textPrompts,
        ...otherOptions,
    };
    if (maskPath)
        formData.mask_image = fs_extra_1.default.createReadStream(await maskPath.filepath());
    const response = await axios_1.default.postForm(Util.makeUrl(util_1.APIVersion.V1, RESOURCE, engineId + '/' + Endpoint.IMAGE_TO_IMAGE_MASKING), axios_1.default.toFormData(formData, new form_data_1.default()), {
        validateStatus: undefined,
        headers: {
            ...this.authHeaders,
            Accept: 'application/json',
        },
    });
    imagePath.cleanup();
    maskPath === null || maskPath === void 0 ? void 0 : maskPath.cleanup();
    if (response.status === 200 && Array.isArray(response.data.artifacts)) {
        return processArtifacts(response.data.artifacts);
    }
    throw new error_1.StabilityAIError(response.status, 'Failed to run image to image masking', response.data);
}
exports.imageToImageMasking = imageToImageMasking;
//# sourceMappingURL=generation.js.map